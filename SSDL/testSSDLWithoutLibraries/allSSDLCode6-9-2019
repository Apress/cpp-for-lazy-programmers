////  SSDL stuff. It compiles! Paste it into your main and you've got it all
//		in one place for easy test-to-destruction

#include <sstream>
#include <SDL.h>
#include <SDL_ttf.h>
#include <iostream>
#include <string>
#include <memory>
#include <SDL_image.h>
#include <vector>
#include "SDL_mixer.h"
#include <iostream>
#include <cassert>
#include <memory.h>

//color
struct SSDL_Color : public SDL_Color
{
public:
	SSDL_Color(const SDL_Color& other) { r = other.r; g = other.g; b = other.b; a = other.a; }
	SSDL_Color(int rIn = 0, int gIn = 0, int bIn = 0, int alpha = 255)
	{
		r = rIn; g = gIn; b = bIn; a = alpha;
	}
	SSDL_Color(const SSDL_Color& other)
	{
		*this = other;
	}
	const SSDL_Color& operator= (const SSDL_Color& other)
	{
		r = other.r; g = other.g; b = other.b; a = other.a;
		return *this;
	}
};

const SSDL_Color BLACK(0, 0, 0), WHITE(255, 255, 255), RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);

inline SSDL_Color SSDL_CreateColor(int r, int g, int b, int a = 255) { return SSDL_Color(r, g, b, a); }

//exception

class SSDL_Exception
{
public:
	SSDL_Exception(const char* message = SDL_GetError()) : contents_(message) {}
	/*SSDL_Exception () : contents_ (SDL_GetError ())
	{
	}*/
	void print(std::ostream& out) const { out << contents_; }
	operator const std::string() const { return contents_; }
	operator const char*	   () const { return contents_.c_str(); }
private:
	std::string contents_;
};

inline
std::ostream& operator<< (std::ostream& out, const SSDL_Exception& foo)
{
	foo.print(out); return out;
}

void SSDL_terminate() //DOES NOT GET CALLED when we are in the Debugger
{
	//yes, but how do I know what exception was thrown?
	//I *could* just call SDL_GetError again -- I think -- but the correct thing is to use
	//What will it display if the error was not SDL?
	try
	{
		throw;
	}
	catch (const SSDL_Exception& c)
	{
		SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "SDL Error", c, NULL); //SDL_GetError (), NULL);
	}

	abort();
}
//font

class SSDL_Font
{
public:
	SSDL_Font(TTF_Font* font = NULL) : ttfFont_(NULL) //WSB: took out SSDL_Font:: for MinGW compile
	{
		ttfFont_.reset(font, TTF_CloseFont);
	}
	SSDL_Font(const SSDL_Font& f) { *this = f; }

	const SSDL_Font& operator= (const SSDL_Font& f) { ttfFont_ = f.ttfFont_; return *this; }
	operator TTF_Font* () { return ttfFont_.get(); }
	operator TTF_Font* () const { return ttfFont_.get(); }

private:
	std::shared_ptr<TTF_Font> ttfFont_;
};

TTF_Font* SSDL_OpenFont(const char* filename, int point);
//This bit all relates to where to get fonts found on the system
//WSB: get something that'll work on Mac too...
#ifdef _WIN32
#define FONT_PATH "C:\\Windows\\Fonts\\"
#elif __unix__
#define FONT_PATH "/usr/share/fonts/truetype/msttcorefonts/"
#endif

inline
TTF_Font* SSDL_OpenSystemFont(const char* filename, int point)
{
	std::string newPath(FONT_PATH); newPath += filename; filename = newPath.c_str();
	return SSDL_OpenFont(filename, point);
}

//What font is current?
TTF_Font* SSDL_GetCurrentFont(); //WSB: should it return const TTF_Font*?
void      SSDL_SetFont(TTF_Font* newFont); //WSB: test with const pointer too?


//display
class SSDL_Image;

class SSDL_Display
{
public:
	enum { DEFAULT_WIDTH = 640, DEFAULT_HEIGHT = 480 };

	static SSDL_Display& Instance()
	{
		static SSDL_Display myInstance;
		return myInstance;
	}

	void RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
	void RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered = false);
	//void scrollVertically  (unsigned int pixels);

	bool isTimeToQuit() const { return isTimeToQuit_; }
	void declareTimeToQuit() { isTimeToQuit_ = true; }

	operator SDL_Renderer* () const { return sdlRenderer_; }
	operator SDL_Window*   () const { return sdlWindow_; }

	void setWindowSize(int w, int h);

	int  advance(char ch) const
	{
		int result;
		if (TTF_GlyphMetrics((TTF_Font*)(const TTF_Font*)SSDL_GetCurrentFont(), ch, NULL, NULL, NULL, NULL, &result))
			throw SSDL_Exception();
		return result;
	}
	int fontLineSkip() const
	{
		return TTF_FontLineSkip((TTF_Font*)SSDL_GetCurrentFont());
		//return TTF_FontLineSkip ((TTF_Font*) (const TTF_Font*) currentFont());
		//why the double cast?  SDL_ttf library's never heard of const -- so we must first convert to ptr, then discard const
	}


	const SSDL_Color& background() const { return background_; }
	void	 setBackground(const SSDL_Color& c) { background_ = c; }

private:
	SDL_Window*   sdlWindow_;
	SDL_Renderer* sdlRenderer_;
	//SDL_Surface*  sdlSurface_; 
	//I am no longer keeping sdlSurface_.  If I need it, I can get it at the last minute
	// with SDL_GetWindowSurface(sdlWindow_) -- but I must not destroy it, or rely on it if something changes
	// like a resize
	SSDL_Color	  background_;

	bool		  isTimeToQuit_;

	SSDL_Display();
	SSDL_Display(const SSDL_Display&);
	const SSDL_Display& operator= (const SSDL_Display&);
	~SSDL_Display(); //pretty sure this must be public.  Why isn't it griping at me? WSB
};



inline bool SSDL_IsQuit() { return SSDL_Display::Instance().isTimeToQuit(); }
inline void SSDL_DeclareQuit() { SSDL_Display::Instance().declareTimeToQuit(); }

inline void SSDL_SetRenderDrawColor(const SSDL_Color& c)
{
	SDL_SetRenderDrawColor(SSDL_Display::Instance(), c.r, c.g, c.b, c.a);
}

inline SSDL_Color SSDL_GetRenderDrawColor()
{
	SSDL_Color c;
	SDL_GetRenderDrawColor(SSDL_Display::Instance(), &c.r, &c.g, &c.b, &c.a);
	return c;
}

inline void SSDL_SetRenderEraseColor(const SSDL_Color& c)
{
	SSDL_Display::Instance().setBackground(c);
}

inline const SSDL_Color& SSDL_GetRenderEraseColor()
{
	return SSDL_Display::Instance().background();
}

inline void SSDL_RenderClearAux()
{
	if (SDL_RenderClear(SSDL_Display::Instance()) < 0) throw SSDL_Exception();
}

void SSDL_RenderClear(const SSDL_Color& c = SSDL_Display::Instance().background());

inline
void SSDL_RenderTextAux(const char* str, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
	SSDL_Display::Instance().RenderText(str, x, y, font);
}

inline
void SSDL_RenderTextCenteredAux(const char* str, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
	SSDL_Display::Instance().RenderText(str, x, y, font, true); //true for "yes, center it"
}

template <typename T>
inline
void SSDL_RenderTextCentered(const T& thing, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
	std::ostringstream os; os << thing;
	SSDL_RenderTextCenteredAux(os.str().c_str(), x, y, font);
}

template <typename T>
inline
void SSDL_RenderText(const T& thing, int x, int y, const TTF_Font* font = SSDL_GetCurrentFont())
{
	std::ostringstream os; os << thing;
	SSDL_RenderTextAux(os.str().c_str(), x, y, font);
}

//...I could do a template specialization here, but it doesn't seem necessary.  It will slow printing of
// strings ever so slightly if I don't.

inline void SSDL_RenderImage(SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst)
{
	if (SDL_RenderCopy(SSDL_Display::Instance(), image, &src, &dst) != 0) throw SSDL_Exception();
}

inline void SSDL_RenderImageEx(SDL_Texture* image, const SDL_Rect& src, const SDL_Rect& dst, double angleInDegrees = 0.0,
	SDL_RendererFlip flipValue = SDL_FLIP_NONE)
{
	SDL_RenderCopyEx(SSDL_Display::Instance(), image, &src, &dst, angleInDegrees, NULL, flipValue);
}

inline void SSDL_QueryImage(SDL_Texture* image, int& w, int& h)
{
	SDL_QueryTexture(image, NULL, NULL, &w, &h);
}

inline int SSDL_GetImageWidth(SDL_Texture* image) { int w, h; SSDL_QueryImage(image, w, h); return w; }
inline int SSDL_GetImageHeight(SDL_Texture* image) { int w, h; SSDL_QueryImage(image, w, h); return h; }

void SSDL_RenderImage(SDL_Texture* image, int x, int y, int stretchWidth = 0, int stretchHeight = 0);

inline void SSDL_RenderPresent() { SDL_RenderPresent(SSDL_Display::Instance()); }

inline void SSDL_GetWindowPosition(int&        x, int&        y)
{
	SDL_GetWindowPosition(SSDL_Display::Instance(), &x, &y);
}
inline void SSDL_GetWindowSize(int& x, int& y)
{
	SDL_GetWindowSize(SSDL_Display::Instance(), &x, &y);
}
inline const char*	SSDL_GetWindowTitle() { return SDL_GetWindowTitle(SSDL_Display::Instance()); }
inline void			SSDL_SetWindowTitle(const char* t) { SDL_SetWindowTitle(SSDL_Display::Instance(), t); }
inline void			SSDL_SetWindowPosition(int x, int y) { SDL_SetWindowPosition(SSDL_Display::Instance(), x, y); }
inline void			SSDL_RestoreWindow() { SDL_RestoreWindow(SSDL_Display::Instance()); }
inline void			SSDL_MinimizeWindow() { SDL_MinimizeWindow(SSDL_Display::Instance()); }
inline void			SSDL_MaximizeWindow() { SDL_MaximizeWindow(SSDL_Display::Instance()); }
inline int          SSDL_GetWindowWidth() { int w, h; SSDL_GetWindowSize(w, h); return w; }
inline int			SSDL_GetWindowHeight() { int w, h; SSDL_GetWindowSize(w, h); return h; }

inline void			SSDL_SetWindowSize(int w, int h) { SSDL_Display::Instance().setWindowSize(w, h); }

//font.cpp

using namespace std;

class BooHoo
{
public:
	static BooHoo& Instance() { static BooHoo myBooHoo; return myBooHoo; }

	TTF_Font* currentFont() const { return currentFont_; }
	void setFont(TTF_Font* newFont) { currentFont_ = newFont; }
private:
	BooHoo()
	{
		currentFont_ = SSDL_OpenSystemFont("arial.ttf", 14);
		TTF_SetFontStyle(currentFont_, TTF_STYLE_BOLD);
	}
	TTF_Font* currentFont_;
};

//I should remember to TTF_CloseFont(newFont) in the dtor for SSDL_Font -- later.
//I'm so relieved it's no longer crashing on closing.


TTF_Font* SSDL_GetCurrentFont()
{
	return BooHoo::Instance().currentFont();
}
void SSDL_SetFont(TTF_Font* newFont) //WSB: test with const pointer too?
{
	BooHoo::Instance().setFont(newFont);
}

bool matchFromEnd(const char* str, const char* substr) //WSB 7-26-2016 not yet tested
{
	char* strEnd = (char*)str + strlen(str) - 1;
	char* substrEnd = (char*)substr + strlen(substr) - 1;

	for (;; --strEnd, --substrEnd)
	{
		if (*substrEnd != *strEnd)  return false;

		if (substrEnd <= substr)    return true;
		else if (strEnd <= str)     return false;
	}
}

TTF_Font* SSDL_OpenFont(const char* filename, int point) //WSB: changed 7-26-2016 and not yet tested
{
	//WSB: How do I know that SDL has been opened?!  Better check!
	SSDL_Display::Instance();

	//We hope the filename ends in .ttf.  If not, and there's no extension, append it.
	//If not, and there is an (incorrect) extension, go ahead and append it, and watch it fail.

	string finalFilename = filename;
	if (!matchFromEnd(filename, ".ttf")) finalFilename += ".ttf";

	//SSDL_Display::Instance (); //be sure it's all set up BEFORE we try to load a font
	TTF_Font* result = TTF_OpenFont(finalFilename.c_str(), point);
	if (!result) throw SSDL_Exception();
	return result;
}

//image

//WSB: this function a) shouldn't be inline and b) shouldn't exist.  It's a patch because SDL_DestroyTexture is 
// being called twice on SDL_Texture owned by SSDL_Image's shared_ptr, and I don't know why.  Fix sometime.

inline
void SSDL_DestroyTexture(SDL_Texture*& p)
{
	//Note:  I would like to erase this function and call SDL_DestroyTexture instead.  But shared_ptr<T>::operator= calls
	// the designated destroy function even if its pointer is nullptr (!).  It should not, and I don't see a way to make
	// it not do this (or call something else that does what = is supposed to do but doesn't).  Fix this when I get
	// Internet access again and can look up a solution -- or else leave this as is.

	//And maybe this would work for throwing exceptions?  
	//if (SDL_GetError() != "") throw SSDL_Exception (); -- or would that change the next call of
	// SDL_Error?

	//WSB
	if (p)
	{
		SDL_DestroyTexture(p);
		p = nullptr;
	}
	//const char* errorString = SDL_GetError ();
	//if (errorString[0] != '\0') //if there's an error
	//			SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "SDL Error", SDL_GetError (), NULL);
}

class SSDL_Image
{
public:
	SSDL_Image() : sdlTexture_(NULL) {  }
	SSDL_Image(SDL_Texture* sdlTexture) : sdlTexture_(NULL)
	{
		sdlTexture_.reset(sdlTexture, SSDL_DestroyTexture);
	}
	SSDL_Image(const SSDL_Image& other) { *this = other; }

	operator SDL_Texture* () { return sdlTexture_.get(); }
	operator SDL_Texture* () const { return sdlTexture_.get(); }

	const SSDL_Image& operator= (const SSDL_Image& other)
	{
		sdlTexture_ = other.sdlTexture_; return *this;
	}
private:
	std::shared_ptr<SDL_Texture> sdlTexture_;	//yes, I do need to use SDL_Texture not SDL_Surface.  
								//Efficiency.  Wd be less efficient if we manipulate the
								// bits... but we won't.
};

SSDL_Image SSDL_LoadImage(const char* filename);

SSDL_Image SSDL_LoadImage(const char* filename)
{
	SSDL_Display::Instance(); //be sure SDL is initialized before calling IMG_Load

	SDL_Surface* sdlSurface = IMG_Load(filename);
	if (!sdlSurface) throw SSDL_Exception();

	SDL_Texture* result = SDL_CreateTextureFromSurface(SSDL_Display::Instance(), sdlSurface);
	if (!result) throw SSDL_Exception(); //sure would be nice if we could convey what
	//file failed!
	SDL_FreeSurface(sdlSurface);

	return SSDL_Image(result);
}

//display.cpp

#ifdef _MSC_VER					//If it's Visual Studio
#pragma warning(disable : 4996)	//Disable the "feature" that makes strcpy an error!
#endif

//What's this crazy stuff here?  I need to ensure that SSDL_Display::Instance()
// is called (thus initializing SDL among other things) before main starts.
//This will do it.  Why do I care?  In case someone does something in main
// with an SDL feature like mouse cursor that I am not supporting.  It won't
// work till SDL is initialized.  Now it is.

//Weakness:  what if they do this SDL feature globally?  Then order of initialization
// is not guaranteed by C++.  But if they know enough to use an SDL feature, they
// should know enough not to do things with it before SDL is initialized.  So there.

//Will Briggs, 11-12-2015

class ThisClassIsJustHereToForceSSDL_DisplayToInitialize
{
public:
	ThisClassIsJustHereToForceSSDL_DisplayToInitialize()
	{
		SSDL_Display::Instance();
	}
};
//static SSDL_Font testerFontForCrash = SSDL_OpenSystemFont("arial.ttf", 12); WSB

static ThisClassIsJustHereToForceSSDL_DisplayToInitialize junk;

SSDL_Display::SSDL_Display() : //background_ (0, 0, 0, 255), foreground_ (255, 255, 255, 255),
	isTimeToQuit_(false)
{
	std::set_terminate(SSDL_terminate);

	if (SDL_Init(SDL_INIT_EVERYTHING) < 0)
		throw SSDL_Exception();


	sdlWindow_ = SDL_CreateWindow("",		//no title by default
		SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
		DEFAULT_WIDTH, DEFAULT_HEIGHT,
		0);		//flags are 0 by default
	if (!sdlWindow_) throw SSDL_Exception();

	//defaults below:  index shd be -1 (pick the first renderer that works best)
	//rendererFlags should be 0
	int rendererIndex = -1;
	int rendererFlags = 0;
	sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);

	if (!sdlRenderer_) throw SSDL_Exception();

	//sdlSurface_ = SDL_GetWindowSurface(sdlWindow_); //need I free this later?  I don't think so.  WSB

	//if (! sdlSurface_ ) throw SSDL_Exception ();

	SDL_ClearError(); //Why? SDL2_Image documentation warns that IMG_Init does not necessarily
					  // set the Error, so I figure I'd better clear it.  I hope it sets it if there's an error!
	static const int IMG_FLAGS = IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF; //all available types
	if (!(IMG_Init(IMG_FLAGS) & IMG_FLAGS)) throw SSDL_Exception();

	if (TTF_Init() == -1) throw SSDL_Exception();

	//Had to avoid calling SSDL_SetRenderDrawColor because it calls SSDL_Display::Instance
	//which calls this ctor, and a thread-safe mechanism got this thing stuck waiting forever
	SDL_SetRenderDrawColor(sdlRenderer_, 255, 255, 255, 255);
	//SSDL_SetRenderDrawColor (SSDL_Color(255,255,255));	//So the default color for drawing is WHITE.  I don't use the constant
														//because I don't _know_ that it's been initialized yet.
}

SSDL_Display::~SSDL_Display() //pretty sure this must be public.  Why isn't it griping at me? WSB
{
	//This should be done as soon as the error condition arises.  Can we make this happen?  I think so -- by
	// rigorously checking return values, from (for example) SDL_DestroyTexture.  But this would require extra code after
	// any particular call, and that seems costly.
	//So at some point:  check for error and throw exceptions more rigorously after each call for which I think the cost
	// is worth it.  WSB

	const char* errorString = SDL_GetError();
	//8-17-2017
	//In Windows 10, if there is no speaker connected, you get a new sound system error every time
	// you try to do something iwth a sound -- it won't just let it go
	//So for now, I won't let errors get reported.  This is NOT optimal.  WSB
	//if (errorString[0] != '\0') //if there's an error
	//			SDL_ShowSimpleMessageBox (SDL_MESSAGEBOX_ERROR, "SDL Error", SDL_GetError (), NULL);

	TTF_Quit();
	IMG_Quit();
	//SDL_DestroyRenderer (sdlRenderer_); //not needed, but OK //It was noticeably causing delay, so I commented it out
	SDL_DestroyWindow(sdlWindow_); //not needed, but OK
	SDL_Quit();
}

void SSDL_RenderImage(SDL_Texture* image, int x, int y, int stretchWidth, int stretchHeight)
{
	//WSB: what if x, y, sW, or sH are negative?
	SDL_Rect dst; //src is dimensions of image; dst is where it's goin on screen
	dst.x = x; dst.y = y;

	if (stretchWidth == 0 || stretchHeight == 0) //what if they put in 0 for either?  then dont' stretch
		SDL_QueryTexture(image, NULL, NULL, &dst.w, &dst.h); //get width and height of image
	else
	{
		dst.w = stretchWidth; dst.h = stretchHeight;
	}

	SDL_RenderCopy(SSDL_Display::Instance(), image, NULL, &dst);
}

void SSDL_Display::RenderText(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
//It's possible that the str may contain \n or \r.  If so, it should be broken into lines
// and printed.  If centered, we need to remember the center point.  If not, we need to remember the starting point
{
	//This is all about splitting str by using strtok
	// Because std::string doesn't support this, I must do my own dynamic memory

	char* temp = new char[strlen(str) + 1]; //strtok destroys its string, so I must make a copy
	strcpy(temp, str);

	char* nextLine = strtok(temp, "\n\r");
	while (nextLine)
	{
		RenderTextLine(nextLine, x, y, font, isCentered);
		y += fontLineSkip();
		nextLine = strtok(NULL, "\n\r");
	}
	delete[] temp;
}

void SSDL_Display::RenderTextLine(const char* str, int x, int y, const TTF_Font* font, bool isCentered)
{
	SDL_Surface* surfaceToPrintOn;
	surfaceToPrintOn = TTF_RenderText_Solid((TTF_Font*)font, str, SSDL_GetRenderDrawColor());
	//arg -- having to cast away that const again.  Why should I have to?
	//I'll assume this is carelessness on the part of SDL2_TTF's creator(s)
	//I can fix this with my own calls
	if (!surfaceToPrintOn) throw SSDL_Exception();


	SDL_Texture* textureToPrint;
	textureToPrint = SDL_CreateTextureFromSurface(sdlRenderer_, surfaceToPrintOn);

	if (!textureToPrint) throw SSDL_Exception();

	int centerAdjustment = isCentered ? surfaceToPrintOn->w / 2 : 0;
	SDL_Rect whereToPutIt = { x - centerAdjustment, y, surfaceToPrintOn->w, surfaceToPrintOn->h };

	if (SDL_RenderCopy(sdlRenderer_, textureToPrint, NULL, &whereToPutIt) < 0)
		throw SSDL_Exception();
	//If we used RenderCopyEx, we could also rotate the text, or mirror it vertically or horizontally
	//Another time perhaps
	SDL_DestroyTexture(textureToPrint);  //<-- WSB MEMORY FIX
	SDL_FreeSurface(surfaceToPrintOn);
}

inline
SDL_Surface* SSDL_CopySurface(SDL_Surface* sdlSurface)
{
	return SDL_ConvertSurface(sdlSurface, sdlSurface->format, 0);
}


/*void SSDL_Display::scrollVertically (unsigned int pixels) //WSB if this is not used, delete it
{
	SDL_Rect srcRect, destRec;
	srcRect.x = destRec.x = 0;
	srcRect.y = pixels;
	destRec.y= 0;
	srcRect.w = destRec.w = sdlSurface_->w; //If I need sdlSurface_, get it at last minute with SDL_GetWindowSurface
	srcRect.h = destRec.h = sdlSurface_->h - pixels;

	SDL_Surface* temp = SSDL_CopySurface (sdlSurface_);
	//SDL_FillRect (temp, &srcRect, SDL_MapRGB (sdlSurface_->format, 255, 255, 255));
	//I don't know if you can copy a surface onto itself...
	SDL_BlitSurface (temp, NULL, sdlSurface_, NULL);
	//SDL_BlitSurface (temp, &srcRect, sdlSurface_, &destRec); //I think it's not blitting -- I think the
	//then a bkgd-color rectangle at the bottom
}
*/
void SSDL_RenderClear(const SSDL_Color& c)
{
	SSDL_Color old = SSDL_GetRenderDrawColor();
	SSDL_SetRenderDrawColor(c);
	SSDL_RenderClearAux();
	SSDL_SetRenderDrawColor(old);
}

void SSDL_Display::setWindowSize(int w, int h)
{
	//#ifdef _WIN32
	SDL_SetWindowSize(SSDL_Display::Instance(), w, h);

	SSDL_RenderPresent();	//In Unix, if I don't do these, the next things
	SDL_PollEvent(nullptr); //drawn will be offset from 0,0. SSDL_WaitKey etc.
							//also do these things (OK, SDL_WaitEvent(ptr)
							//not SDL_PollEvent(nullptr)). IDK yet why this
							//is needed. -- WB 6-5-2019


//#elif __unix__
//
//	//We SHOULD be able to just resize, and renderer gets that info automatically -- but nothing's working
//		//right now but a complete recreation of window and renderer!
//	SDL_DestroyRenderer(sdlRenderer_); //WSB: you cd call this from the ctor and save some code
//	SDL_DestroyWindow(sdlWindow_);
//	sdlWindow_ = SDL_CreateWindow("",
//		SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
//		w, h, 
//		0);
//
//	int rendererIndex = -1, rendererFlags = 0;
//	sdlRenderer_ = SDL_CreateRenderer(sdlWindow_, rendererIndex, rendererFlags);
//#endif
}


//sound

//An SSDL_SoundSystem is the thing which calls Mix_OpenAudio on startup and Mix_CloseAudio on closing
//It's there so we can remember to declare it once, rather than remembering to call Mix_OpenAudio w/
// all its paramemters and remember to call Mix_CloseAudio.

class SSDL_SoundSystem
{
public:
	static SSDL_SoundSystem& Instance()
	{
		static SSDL_SoundSystem myInstance; //WSB:  but I should let them set the parameters!  How?
		return myInstance;
	}
	bool initialized() const { return initializedOK_; }
private:
	SSDL_SoundSystem(int freq = MIX_DEFAULT_FREQUENCY, Uint16 format = AUDIO_U8,
		int channels = MIX_DEFAULT_CHANNELS, int    chunkSize = 4096);
	//MIX_DEFAULT_CHANNELS == 2 == stereo.  1 is mono.  Should I make this a bool? WSB
	//http://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_11.html says it's got nothing to do w channels

	//Special thanks to whoever wrote http://sdl.beuc.net/sdl.wiki/Mix_OpenAudio ,
	//which said that setting format to AUDIO_S16, AUDIO_U16, AUDIO_S16LSB, or AUDIO_U16LSB
	// causes the horrible staticky sound I was hearing.  And the usual default format,
	// MIX_DEFAULT_FORMAT, equalled one of these!  I tried AUDIO_U8 and it worked.

	~SSDL_SoundSystem()
	{
		if (initializedOK_)
		{
			Mix_AllocateChannels(0); Mix_CloseAudio();
		}
	} //deallocate channels, close audio
	SSDL_SoundSystem(const SSDL_SoundSystem&);                 //don't allow use of copy ctor
	const SSDL_SoundSystem& operator= (const SSDL_SoundSystem&);//or operator=

	bool initializedOK_ = false; //8-7-2017
};

//An SSDL_Sound is essentially a wrapper for SDL_Mixer's Chunk struct
//It's used for sound effects.
//Warning:  memory problems, including crashing, will occur if more than one SSDL_Sound shares its chunk
//This is possible but unlikely
//Using auto_ptr in the class definition s no sure protection, as the programmer using this library might not also use it
//I did what I could by making operator= (const SSDL_Sound&) private
//Now it's up to the programmer

class SSDL_Sound
{
public:
	enum { NO_CHANNEL = -1 };
	SSDL_Sound(Mix_Chunk* soundChunk = NULL) : channel_(-1), chunk_(NULL)
	{
		SSDL_SoundSystem::Instance(); //so that it's created before I try to do anything with it
		//setTo (soundChunk);
		channel_ = NO_CHANNEL;

		chunk_.reset(soundChunk, Mix_FreeChunk);
	}
	SSDL_Sound(const SSDL_Sound& s) { *this = s; }

	/*const SSDL_Sound& operator= (Mix_Chunk* newSound)
	{
		setTo (newSound);

		return *this;
	}*/
	const SSDL_Sound& operator= (const SSDL_Sound& s)
	{
		chunk_ = s.chunk_; return *this;
	}
	~SSDL_Sound()
	{
	}

	operator int() const { return channel_; }
	operator Mix_Chunk* () const { return chunk_.get(); }

	//WSB: make this not inline so I can hide it!
	void setChannel(int c) const //And justify these convolutions to make
								  // it possible to play constant sounds
	{
		const int* channelPtr = &channel_;
		int* channelPtr2 = (int*)channelPtr;
		*channelPtr2 = c;

		//channel_ = c;
	}

private:
	//SDL_Mixer uses "channels" for its sound effects.  Each sound has its own channel, which is an int
	int						channel_;	//the channel the sound will play on

	std::shared_ptr<Mix_Chunk> chunk_;
};

inline Mix_Chunk* SSDL_LoadWAV(const char* file)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return NULL;
	SSDL_SoundSystem::Instance();				//start the sound system BEFORE any calls to the mixer
	Mix_Chunk* result = Mix_LoadWAV(file);
	if (!result)
		throw SSDL_Exception(); //8-7-2017

	return result;
}

inline int SSDL_VolumeSound(int channel, int volume = MIX_MAX_VOLUME) { return Mix_Volume(channel, volume); }
inline int SSDL_VolumeAllSounds(int volume = MIX_MAX_VOLUME) { return Mix_Volume(-1, volume); }

void SSDL_PlaySound(const SSDL_Sound& sound, int repeats = 0);
void SSDL_FadeInSound(SSDL_Sound& sound, int repeats, int ms);
void SSDL_PlaySoundTimed(SSDL_Sound& sound, int repeats, int ticks);
void SSDL_FadeInSoundTimed(SSDL_Sound& sound, int repeats, int ms, int ticks);

inline void		SSDL_PauseSound(int channel) { Mix_Pause(channel); }
inline void		SSDL_PauseAllSounds() { Mix_Pause(-1); }
inline void		SSDL_ResumeSound(int channel) { Mix_Resume(channel); }
inline void		SSDL_ResumeAllSounds() { Mix_Resume(-1); }
inline void		SSDL_HaltSound(int channel) { Mix_HaltChannel(channel); }
inline void		SSDL_HaltAllSounds() { Mix_HaltChannel(-1); }

inline bool		SSDL_SoundPlaying(int channel) { return Mix_Playing(channel) != 0; }
inline bool		SSDL_SoundPaused(int channel) { return Mix_Paused(channel) != 0; }
inline Mix_Fading SSDL_SoundFadingChannel(int channel) { return Mix_FadingChannel(channel); }

inline int		SSDL_ExpireSound(int channel, int ms) { return Mix_ExpireChannel(channel, ms); }
inline int		SSDL_ExpireAllSounds(int ms) { return Mix_ExpireChannel(-1, ms); }
inline int		SSDL_FadeOutSound(int channel, int ms) { return Mix_FadeOutChannel(channel, ms); }
inline int		SSDL_FadeOutAllSounds(int ms) { return Mix_FadeOutChannel(-1, ms); }

//An SSDL_Music is essentially a wrapper for SDL_Mixer's Mix_Music.
//Note that music (Mix_Music) and sound effects (Mix_Chunk) are different things
// done differetnly in SDL_Mixer.

//You can only have one of it.  But I don't want it to be a conventional singleton
// class, because it makes sense for a user to declare it (so we need the ctor available)
//So I'll just make the only data member static.  This way you can declare as many
// SSDL_Musics as you like...but they're all the same one.

class SSDL_Music
{
public:
	SSDL_Music(Mix_Music* m = NULL)
	{
		SSDL_SoundSystem::Instance(); //so that it's created before I try to do anything with it
		setTo(m);
	}

	//Never call copy ctor or this version of =
	SSDL_Music(const SSDL_Music&)
	{
		throw SSDL_Exception("SSDL_Music copy ctor should never be called.");
		//Why  this?  With MinGW, if I delete the copy ctor, it complains that this is needed.  In gdb, it
		// never calls it.  For now, I'll throw this exception.  Later, see if using move ctor is enough
		// to make the error disappear.
	}
	const SSDL_Music& operator= (const SSDL_Music&) = delete;

	const SSDL_Music& operator= (Mix_Music* m)
	{
		setTo(m);
		return *this;
	}
	~SSDL_Music() { if (music_) Mix_FreeMusic(music_); music_ = NULL; }

	operator Mix_Music* () const { return music_; }
	operator Mix_Music* () { return music_; }

	void setTo(Mix_Music* m)
	{
		if (music_) Mix_FreeMusic(music_);		//throw back the old music; get new one
		music_ = m;
	}
private:
	static Mix_Music* music_;
};

enum { SSDL_FOREVER = -1 };

inline Mix_Music* SSDL_LoadMUS(const char* filename)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return NULL;
	SSDL_SoundSystem::Instance();				//start the sound system BEFORE any calls to the mixer
	Mix_Music* result = Mix_LoadMUS(filename);
	if (!result) throw SSDL_Exception();	//8-7-2017
	return result;
}


inline void SSDL_PlayMusic(Mix_Music* m, int loops = SSDL_FOREVER)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return;
	if (Mix_PlayMusic(m, loops) < 0) throw SSDL_Exception();
}
inline void SSDL_FadeInMusic(Mix_Music* m, int loops, int ms)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return;
	if (Mix_FadeInMusic(m, loops, ms) < 0) throw SSDL_Exception();
}
inline void SSDL_FadeInMusicPos(Mix_Music* m, int loops, int ms, double pos)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return;
	if (Mix_FadeInMusicPos(m, loops, ms, pos) < 0) throw SSDL_Exception();
}
inline int  SSDL_VolumeMusic(int volume = -1) { return Mix_VolumeMusic(volume); }

inline void SSDL_PauseMusic() { Mix_PauseMusic(); }
inline void SSDL_ResumeMusic() { Mix_ResumeMusic(); }
inline void SSDL_RewindMusic() { Mix_RewindMusic(); }
inline void SSDL_HaltMusic() { Mix_HaltMusic(); }

inline void SSDL_SetMusicPosition(double pos)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return;
	if (Mix_SetMusicPosition(pos) < 0) throw SSDL_Exception();
}
inline void SSDL_FadeOutMusic(int ms)
{
	if (!SSDL_SoundSystem::Instance().initialized()) return;
	if (!Mix_FadeOutMusic(ms)) throw SSDL_Exception();
}

inline Mix_MusicType SSDL_GetMusicType(const Mix_Music* music) { return Mix_GetMusicType(music); }

inline bool SSDL_PlayingMusic() { return Mix_PlayingMusic() != 0; }
inline bool SSDL_PausedMusic() { return Mix_PausedMusic() != 0; }
inline Mix_Fading SSDL_FadingMusic() { return Mix_FadingMusic(); }

//SSDL SoundSystem
SSDL_SoundSystem::SSDL_SoundSystem(int freq, Uint16 format, int channels, int chunkSize)
{
	initializedOK_ = (Mix_OpenAudio(freq, format, channels, chunkSize) != -1); //8-7-2017
	if (!initializedOK_) SDL_ClearError(); //or we'll get this complaint later, when it makes no sense
	//I commented out all refs to throwing SSDL_Exception in SSDL_sound.*, so we could get by with this
	//It may not be the best solution.
	//Fix later.  8-7-2017

	//if (Mix_OpenAudio(freq, format, channels, chunkSize) == -1)
	//		throw SSDL_Exception (); //WSB: does this create an SDL_GetError?
}

Mix_Music* SSDL_Music::music_ = NULL;

void SSDL_PlaySound(const SSDL_Sound& sound, int repeats)
{
	int result = Mix_PlayChannel(sound, sound, repeats);
	if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
	sound.setChannel(result);
}

void SSDL_FadeInSound(SSDL_Sound& sound, int repeats, int ms)
{
	int result = Mix_FadeInChannel(sound, sound, repeats, ms);
	if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
	sound.setChannel(result);
}

void SSDL_PlaySoundTimed(SSDL_Sound& sound, int repeats, int ticks)
{
	int result = Mix_PlayChannelTimed(sound, sound, repeats, ticks);
	if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
	sound.setChannel(result);
}

void SSDL_FadeInSoundTimed(SSDL_Sound& sound, int repeats, int ms, int ticks)
{
	int result = Mix_FadeInChannelTimed(sound, sound, repeats, ms, ticks);
	if (SSDL_SoundSystem::Instance().initialized()) if (result == -1) throw SSDL_Exception();
	sound.setChannel(result);
}

//timer

void SSDL_SetFramesPerSecond(int FPS);
bool SSDL_Sync();

bool SSDL_IsNextFrame(); //updates screen, verifies there's no quit message found earlier
bool SSDL_IsQuitMessage(); //updates screen, polls events, verifies there's no (possibly new) quit message

inline void SSDL_Delay(Uint32 milliseconds)
{
	if (SSDL_IsQuitMessage()) return; //Hitting Esc or killing window will
									   // skip the delay to come.  Won't interrupt
									   // the delay if it's already going.  Fixable?
	SSDL_RenderPresent(); SDL_Delay(milliseconds);
}

class SSDL_Timer
{
public:
	static SSDL_Timer& Instance()
	{
		static SSDL_Timer myInstance;
		return myInstance;
	}
	void setFramesPerSecond(int fps) { frameDuration_ = 1000 / fps; }
	//maybe I shd just do frame duration as 1/60 of a second?
	bool sync();
private:
	SSDL_Timer() : timeAtNextFrame_(0)
	{
		setFramesPerSecond(60);	//default to 60 frames per second.
	}
	SSDL_Timer(const SSDL_Timer&);
	const SSDL_Timer& operator= (const SSDL_Timer&);

	Uint32 frameDuration_;		//in milliseconds
	Uint32 timeAtNextFrame_;	//in milliseconds, counting from time we started SDL
};

// Frame Per Second Function  , put this in a loop
bool SSDL_Timer::sync()
{
	//ARGH! @#4%!! I now have to PeepEvents... and which one will be the right one?  GODDAMIT!  I want sync
	//to set isTimeToQuit WITHOUT the programmer having to do this!

	//And that can't be done since the programmer will be polling events... while we might miss one.
	//I suppose I can give them the code for it:

	if (SSDL_Display::Instance().isTimeToQuit()) return false;

	SSDL_RenderPresent();

	//SDL_GetTicks returns current time (since SDL was initialized)
	//if the time at the next frame is later than that, wait.  How long?  The difference
	if (timeAtNextFrame_ > SDL_GetTicks())
	{
		SSDL_RenderPresent();
		SDL_Delay(timeAtNextFrame_ - SDL_GetTicks());
	}

	//Now set the time at the next frame to the current time, plus the duration of one frame
	timeAtNextFrame_ = SDL_GetTicks() + frameDuration_;

	return true;
}

void SSDL_DefaultEventHandler(); //It's actually below somewhere
bool SSDL_IsQuitMessage()
{
	SSDL_DefaultEventHandler();
	return !SSDL_IsNextFrame();
}

void SSDL_SetFramesPerSecond(int FPS) { SSDL_Timer::Instance().setFramesPerSecond(FPS); }
bool SSDL_IsNextFrame() { return SSDL_Timer::Instance().sync(); }

//io

typedef SDL_Event SSDL_Event; //simple renaming -- now you can use either

enum { MOUSE_LEFT = 1, MOUSE_RIGHT = 4, MOUSE_MIDDLE = 2 };
void SSDL_GetMousePosition(int& x, int& y);

bool SSDL_IsKeyPressed(int whichKey);

inline int SSDL_GetMouseClick() { return SDL_GetMouseState(NULL, NULL); }
inline int SSDL_GetMouseX() { int x, y; SDL_GetMouseState(&x, &y); return x; }
inline int SSDL_GetMouseY() { int x, y; SDL_GetMouseState(&x, &y); return y; }

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& event);
//Note that these wait functions also stop waiting if you get a SDL_QUIT event.
//Should I also stop waiting if someone hits Esc?  I could do that, but make it
// conditional (you can turn it off)
//Note:  You CANNOT OR events together -- they are not distinct bits!

int  SSDL_WaitMouse();
SDL_Keycode SSDL_WaitKey(); //SDL_Keycode is SDL's virtual key rep. *Sometimes* casting to char gets you what you hit

void SSDL_ToggleEscapeIsQuit();

inline int SSDL_PollEvent(SDL_Event& event) { return SDL_PollEvent(&event); }

void SSDL_DefaultEventHandler();

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent);

//io.cpp
static bool isEscapeMeansQuit = true; //make this something that starts with "SSDL_"
//static bool isVisible = true;        
void SSDL_ToggleEscapeMeansQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

bool SSDL_IsKeyPressed(int whichKey)
{	//The !=0 at the end is to suppress a coercion from Uint8 to bool warning
	//SDL_GetScancodeFromKey:  SDL_GetKeyboardState returns an array that'll tell you
	// what scancodes are currently pressed.  We want to know which keys.  So we must
	// convert
	return SDL_GetKeyboardState(NULL)[SDL_GetScancodeFromKey(whichKey)] != 0;
}

void SSDL_CheckForQuitMessages(const SDL_Event& sdlEvent)
{
	if (sdlEvent.type == SDL_QUIT) SSDL_Display::Instance().declareTimeToQuit();
	if (isEscapeMeansQuit && sdlEvent.type == SDL_KEYDOWN
		&& sdlEvent.key.keysym.scancode == SDL_SCANCODE_ESCAPE)
		SSDL_Display::Instance().declareTimeToQuit();
}

void SSDL_WaitEvent(Uint32 eventType, SDL_Event& sdlEvent)
{
	//if (isVisible) 
	SSDL_RenderPresent();
	//Why this?  because it's annoying to have the screen not update while you're
	//waiting for an event!

	while (!SSDL_Display::Instance().isTimeToQuit())
	{
		if (SDL_WaitEvent(&sdlEvent) == 0) throw SSDL_Exception();
		SSDL_CheckForQuitMessages(sdlEvent);
		if (sdlEvent.type == eventType) return;
	}
}

void SSDL_ToggleEscapeIsQuit() { isEscapeMeansQuit = !isEscapeMeansQuit; }

void SSDL_DefaultEventHandler()
{
	SSDL_Event event;

	while (SSDL_PollEvent(event))
		switch (event.type)
		{
		case SDL_QUIT:    SSDL_DeclareQuit(); break;
		case SDL_KEYDOWN: if (SSDL_IsKeyPressed(SDLK_ESCAPE)) SSDL_DeclareQuit();

			//The rest of these you should probably leave alone.
				//First: if the window is minimized, make a note we don't need to draw it until it isn't
			//case SDL_WINDOWEVENT_MINIMIZED:    isVisible = false; break;

				//Second: if it stopped being minimized, make a note we DO need to draw it
		case SDL_WINDOWEVENT_MAXIMIZED:
		case SDL_WINDOWEVENT_RESTORED:     //isVisible = true; 

			//...and if it was just made visible, or was obscured and is now less so, or
			//  was resized, do an immediate update
		case SDL_WINDOWEVENT_SIZE_CHANGED:
		case SDL_WINDOWEVENT_EXPOSED:      SDL_RenderPresent(SSDL_Display::Instance());
			break;
		}
}

int  SSDL_WaitMouse()
{
	SDL_Event event;
	SSDL_WaitEvent(SDL_MOUSEBUTTONDOWN, event);
	return event.button.button;
}

SDL_Keycode SSDL_WaitKey()
{
	SDL_Event event;
	SSDL_WaitEvent(SDL_KEYDOWN, event);
	return event.key.keysym.sym;
}


//stream

//extern SSDL_Font* currentFont; //move to SSDL_font, and make it generally avaiable?

//SDL has a cursor, but that's for mouse.
//I need one for my stream IO.
//I will make it as a square, based on font size, with a line at the bottom.
//It will be drawn to cursorX, cursorY location
//Backspace should move it back, leaving behind an empty box (use SSDL_Display background color)
//When we put text there, make sure to erase it!

//scrolling will be triggered when cursorY() gets to within fontLineSkip*2 pixels of the bottom of the screen.
//It will capture the screen, 0 to maxX, fontLineSkip to maxY;
// paste it onto the screen at position 0, 0
// past an empty rectangle of SSDL_Display's background color at position 0, maxY-fontLineSkip

//I'm pretty sure this is all do-able


class SSDL_StreamIOSystem
{
public:
	static SSDL_StreamIOSystem& Instance()
	{
		static SSDL_StreamIOSystem myStreamIOSystem;
		return myStreamIOSystem;
	}
	//const SSDL_Font& currentFont () const { return *currentFont_; }
	//void setCurrentFont (const SSDL_Font& newFont)    { currentFont_ = (SSDL_Font*) & newFont; } //SDL2_TTF doesn't do const -- but I do.  Must cast.
	TTF_Font* currentFont() const { return SSDL_GetCurrentFont(); }

	int  cursorX() const { return cursorX_; }
	int  cursorY() const { return cursorY_; }
	int& cursorX() { return cursorX_; }
	int& cursorY() { return cursorY_; }
	void setCursor(int x, int y) { cursorX_ = x; cursorY_ = y; }
	void eraseCharAtCursor(char c); //should not be called after changing font... odd things'll happen

private:
	SSDL_StreamIOSystem() : /*currentFont_ (NULL), */cursorX_(0), cursorY_(0)
	{
	}
	SSDL_StreamIOSystem(const SSDL_StreamIOSystem&);
	const SSDL_StreamIOSystem& operator= (const SSDL_StreamIOSystem&);

	//SSDL_Font* currentFont_;
	int cursorX_, cursorY_;
};

//It would be nice if I let them load a font file and set stream I/O to use it in one command!
//Memory issues.  Argh.  Fix later.  WSB

inline void SSDL_SetCursor(int x, int y) { SSDL_StreamIOSystem::Instance().setCursor(x, y); }

/*
If newFont goes away (wherever SSDL_SetStreamIOFont was called from, currentFont now points to nothing.
But we have no way of copying a font.  We could only store its file name and point and reload it, which
  is slow and not SDL-like.
So we'll tell the library users:  don't set to a font and then let that font go out of scope -- then
  the current font will be gone!  That's not too unreasonable.
*/

//Does all this really need to be template?

template<class _Elem, class _Traits = std::char_traits <_Elem> >
class SSDL_BufferOut : public std::basic_streambuf<_Elem, _Traits>
{
public:
	typedef _Elem                           char_type;
	typedef _Traits                         traits_type;
	typedef typename traits_type::int_type int_type;
	typedef typename traits_type::off_type off_type;
	typedef typename traits_type::pos_type pos_type;

	SSDL_BufferOut() { } //currentFont is getting trashed when I reach this line! !@#%%!! WSB
	void printChar(_Elem ch); //put in protected:?
protected:
	int_type overflow(int_type c = traits_type::eof());
};

template <class charType, class TraitsType>
void SSDL_BufferOut<charType, TraitsType>::printChar(charType ch)
{
	//fontLineSkip is how far to go down to next line
	//advance is how far to go right to next char
	//it varies except in fixed-width font
	//This may blow away my hope of saving time by sending entire strings -- or not.  Not sure
	// it'll be O(N) to find the advance, but I don't know how long it takes to render a string

	//Why all this casting to TTF_Font*?  Because SDL2_ttf library hasn't heard of const, so it objects
	// when I send a const pointer.
	int fontLineSkip = TTF_FontLineSkip((TTF_Font*)(const TTF_Font*)SSDL_StreamIOSystem::Instance().currentFont()); //and what font is that?
	int myAdvance;
	if (TTF_GlyphMetrics((TTF_Font*)(const TTF_Font*)SSDL_StreamIOSystem::Instance().currentFont(), ch, NULL, NULL, NULL, NULL, &myAdvance))
		throw SSDL_Exception();
	static char buf[2] = { '\0' };
	//static int cursorX = 0, cursorY = 0; //DEFINITELY we will move this soon.

	switch (ch)
	{
	case '\n':
	case '\r':
		SSDL_StreamIOSystem::Instance().cursorY() += fontLineSkip;
		SSDL_StreamIOSystem::Instance().cursorX() = 0;
		break;
	case '\t':
		SSDL_StreamIOSystem::Instance().cursorX() = (((SSDL_StreamIOSystem::Instance().cursorX() / myAdvance) / 8) + 1) * 8 * myAdvance; //8 spaces per tab, by convention
		break;
	default:
		buf[0] = ch;
		SSDL_RenderText(buf, SSDL_StreamIOSystem::Instance().cursorX(), SSDL_StreamIOSystem::Instance().cursorY(), (TTF_Font*)(const TTF_Font*)SSDL_StreamIOSystem::Instance().currentFont());
		SSDL_StreamIOSystem::Instance().cursorX() += myAdvance;
	}
}

template <class _ELem, class _Traits>
typename SSDL_BufferOut<_ELem, _Traits>::int_type
SSDL_BufferOut<_ELem, _Traits>::overflow(typename SSDL_BufferOut<_ELem, _Traits>::int_type c)
{
	//This is likely inefficient:  better to send big chunks rather than individual chunks
	//Later, make SSDL use this aright.  For now...
	printChar(c);
	//PRINT IT ON THE SCREEN -- I think!
	//return std::basic_filebuf<_ELem, _Traits>::overflow (c);

	//return something that isn't _Traits::eof() -- unless we fail somehow
	//What if we're passed eof?  Should we return failure (eof)?

	return 0; //Is this OK?
	//return (! _Traits::eof ());
}

template <class charT, class traits = std::char_traits<charT> >
class SSDL_BufferIn : public std::basic_streambuf<charT, traits>
{
public:
	enum { BUFFER_SIZE = 256 };

	typedef charT                          char_type;
	typedef traits                         traits_type;
	typedef typename traits_type::int_type int_type;
	typedef typename traits_type::off_type off_type;
	typedef typename traits_type::pos_type pos_type;

	SSDL_BufferIn()
	{
		this->setg(buffer_, buffer_, buffer_);
		//This tells C++ where the read buffer starts, where it ends, and where the next char to read is
		// We offset it so there is an area to prepend things?  Don't know yet
	}
protected:
	int numCharsInBuffer() const { return int(this->egptr() - this->gptr()); }//it's the end position minus the next-char position
	char buffer_[BUFFER_SIZE]; //OK, but what if it grows too high? //should it be an int array?  setg says no

	int_type underflow();
	int_type pbackfail(int_type c);
private:
	int_type  getMoreChars();
	void egbump(int n)           //I wonder why this isn't built in?  moves end ptr by n units.
	{
		this->setg(this->eback(), this->gptr(), this->egptr() + n);
	}

	void handleBackspace(bool& charRemoved);			//used by getMoreChars ()
	void addACharacter(char c, bool& quit);				//used by getMoreChars ()
};

extern std::ostream sout;
extern std::istream ssin;

//As I understand it, underflow is here for when the istream class wants another character, it can get it
// from the source I provide (the buffer, if there is anything in it; if not, from the device that gives us chars)
template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::underflow()
{
	if (numCharsInBuffer() > 0)						//If we have a char in the buffer to provide...
		return TraitsType::to_int_type(*(this->gptr()));	//... return it!  Job complete
	else if (getMoreChars() > 0)						//Can we get one from the device?
		return TraitsType::to_int_type(*(this->gptr()));	//If so, we did it; return the next char available
	else											//NO way to get a character!  Oh, no!  Return failure
		return TraitsType::eof();
}

template <class charType, class TraitsType>
void SSDL_BufferIn<charType, TraitsType>::handleBackspace(bool& charRemoved)	//process a backspace in my input
{
	charRemoved = false;

	if (this->egptr() != this->eback() && SSDL_StreamIOSystem::Instance().cursorX() > 0) //last condition:  can we be assured it's right?  Cd we be
		//off by a few pixels?
	{
		char prevChar = *((this->egptr()) - 1);
		switch (prevChar)
		{
		case '\n':
		case '\r':
		case -1: //eof
			break;
		default:
			SSDL_StreamIOSystem::Instance().cursorX()
				-= SSDL_Display::Instance().advance(prevChar);

			SSDL_StreamIOSystem::Instance().eraseCharAtCursor(prevChar); //erase the char backspaced over

			assert(SSDL_StreamIOSystem::Instance().cursorX() >= 0); //we shd've had at least 1 char on line, plus my new blank space!
			egbump(-1); //move gptr back 1 space, so we're ignoring where we were
			charRemoved = true;

			break;
		}
	}
}

inline bool isNumLockOn(SDL_Keymod mod) { return (mod & KMOD_NUM) != 0; }

//We got a character through ssin... display it and send it where it should go.
template <class charType, class TraitsType>
void  SSDL_BufferIn<charType, TraitsType>::addACharacter(char c, bool& OKWereDone)
{
	//char* gptrVal  = this->gptr(); //WSB:  these are apparently not used; remove soon.  7-26-2016
	//char* egptrVal = this->egptr();

	if (this->gptr() >= this->eback() + BUFFER_SIZE - 1) //no room!
	{
		OKWereDone = true;	//What will this look like?  Test with tiny buffer size.
		return;
	}

	sout << c;
	*(this->egptr()) = c;
	egbump(1); //move end pointer one step further
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type  SSDL_BufferIn<charType, TraitsType>::getMoreChars()
{
	//As it is, unless you backspace, you _never_ have gptr going back...and it should!  Can I be guaranteed
	// that every time istream calls underflow, it ate all the chars SSDL_BufferIn provided?  Yes!  So I will
	//move everything back.

	assert(this->eback() == buffer_); //if not, why not?
	if (this->gptr() != this->eback())
		memmove(this->eback(), this->gptr(), this->egptr() - this->gptr()); // I think this'll move things back!

	bool OKWereDone = false;
	int  numCharsRead = 0;

	//I broke the SSDL_WaitEvent apart and used this SDL_PollEvent instead, but I could have used SSDL_WaitEvent if I'd changed the line
	// testing type of event from if (eventWeGot==desiredType) to if (eventWeGot & desiredType).  But I may just leave it this way
	// since it's closer to SDL and thus maybe easier to debug.  WSB 2015 November.

	while (!OKWereDone)
	{
		SDL_Event event;
		SSDL_RenderPresent();	//Why this?  because it's annoying to have the screen not update while you're
								//waiting for an event!

		while (SDL_PollEvent(&event) != 0)
		{
			SDL_Keymod   mod = SDL_GetModState();
			bool	     isNumLock = isNumLockOn(mod);
			SDL_Scancode scancode;

			//If a quit message came, let's get out.
			SSDL_CheckForQuitMessages(event);
			if (SSDL_Display::Instance().isTimeToQuit())
			{
				OKWereDone = true;  break;
			}

			//Now let's process two kinds of messages.  SDL_KEYDOWN for when we get a backspace or a return
			//SDL_TEXTINPUT for when we get useful, printable text.

			switch (event.type)
			{
			case SDL_KEYDOWN:
				scancode = event.key.keysym.scancode;
				if (scancode == SDL_SCANCODE_BACKSPACE || (!isNumLock && scancode == SDL_SCANCODE_KP_BACKSPACE))
				{
					bool charRemoved;
					handleBackspace(charRemoved);
					if (charRemoved) --numCharsRead;
				}
				if (scancode == SDL_SCANCODE_RETURN || scancode == SDL_SCANCODE_RETURN2)
				{
					OKWereDone = true;

					addACharacter(event.key.keysym.sym, OKWereDone);		++numCharsRead;
				}
				break;
			case SDL_TEXTINPUT:
				addACharacter(event.text.text[0], OKWereDone);				++numCharsRead;
			}
		}
	}

	return numCharsRead;

	////assert:  numCharsInBuffer() == 0, that is, gptr() == eback() == egptr(), that is, start==next==finish
	//int result = getCharsSomehow ();
	//if (result <= 0) return -1; //getChars failed; return failure.  Should NEVER HAPPEN
	//else
	//	setg (buffer_ ,
	//		  buffer_ ,
	//		  buffer_ +result;
}

template <class charType, class TraitsType>
typename SSDL_BufferIn<charType, TraitsType>::int_type SSDL_BufferIn<charType, TraitsType>::pbackfail(int_type c)
{
	if (this->gptr() == this->eback()) //if there is no further back we can go -- we're at start of buffer
		return TraitsType::eof(); //then failse
	else
	{
		this->gbump(-1); //back up one space
					//and if there's no EOF where we just went, put our char there
		if (!TraitsType::eq_int_type(c, TraitsType::eof()))
		{
			*(this->gptr()) = TraitsType::to_char_type(c);
			return c;
		}
		else
			return TraitsType::not_eof(c);
	}
}

//stream.cpp

using namespace std;

static SSDL_BufferOut <char> ssdlBufferOut;
std::ostream sout(&ssdlBufferOut);

static SSDL_BufferIn <char> ssdlBufferIn;
istream ssin(&ssdlBufferIn);

void SSDL_StreamIOSystem::eraseCharAtCursor(char c) //should not be called after changing font... odd things'll happen
{
	SDL_Surface* result = SDL_CreateRGBSurface(0, 1, 1, 4, 0, 0, 0, 1);
	//	SDL_Rect rect = {0, 0, 1, 1};

		//erase that last char by replacing with background color
	SDL_Rect newRect;
	newRect.x = cursorX(); newRect.y = cursorY();
	newRect.w = SSDL_Display::Instance().advance(c);
	newRect.h = SSDL_Display::Instance().fontLineSkip();
	Uint8 r, g, b, a;
	SDL_GetRenderDrawColor(SSDL_Display::Instance(), &r, &g, &b, &a); //save current draw 
	SSDL_Color background_ = SSDL_Display::Instance().background();
	SDL_SetRenderDrawColor(SSDL_Display::Instance(), background_.r, background_.g, background_.b, background_.a);
	SDL_RenderFillRect(SSDL_Display::Instance(), &newRect);
	SDL_SetRenderDrawColor(SSDL_Display::Instance(), r, g, b, a); //Restore prev draw color
	SSDL_RenderPresent();

	SDL_FreeSurface(result);
}

//sprite

class SSDL_Sprite : public SSDL_Image
{
public:
	//5-19-2016 //SSDL_Sprite (SDL_Texture* t = NULL) 	{	setImage (t);		}
	SSDL_Sprite() { setImage(NULL); } //5-19-2016
	SSDL_Sprite(const SSDL_Sprite& other) { *this = other; }
	SSDL_Sprite(const SSDL_Image& other) { setImage(other); }
	const SSDL_Sprite& operator= (const SSDL_Sprite& other);

	void setImage(const SSDL_Image& t); //and adjust other fields to their defaults

	SDL_Rect destination() const;	//rectangle that's where it'll go on the screen
	SDL_Rect source() const;	//rectangle that's where it's coming from in the image

	int  x() const { return x_; }
	int  y() const { return y_; }
	int  width() const { return width_; }
	int  height() const { return height_; }
	int  clipX() const { return clipX_; }
	int  clipY() const { return clipY_; }
	int  clipWidth() const { return clipWidth_; }
	int  clipHeight() const { return clipHeight_; }
	int  offsetX() const { return offsetX_; }
	int  offsetY() const { return offsetY_; }
	bool flipHorizontal() const { return flipHorizontal_; }
	bool flipVertical() const { return flipVertical_; }
	double angleOfRotation() const { return angleOfRotation_; }

	int&  x() { return x_; }
	int&  y() { return y_; }
	int&  width() { return width_; }
	int&  height() { return height_; }
	int&  clipX() { return clipX_; }
	int&  clipY() { return clipY_; }
	int&  clipWidth() { return clipWidth_; }
	int&  clipHeight() { return clipHeight_; }
	int&  offsetX() { return offsetX_; }
	int&  offsetY() { return offsetY_; }
	bool& flipHorizontal() { return flipHorizontal_; }
	bool& flipVertical() { return flipVertical_; }
	double& angleOfRotation() { return angleOfRotation_; }

private:
	void zeroFields(); //used by ctors.  Sets everything in sight to a default of 0.

	//x and y are the position of the sprite's reference point (by default, its top left corner) on the screen
	//w and h are its width and height, on the screen
	int x_, y_, width_, height_;

	//offset is how far the reference point is, down and right, from the top left corner; default is 0,0
	int offsetX_, offsetY_;

	//clipX_, etc., are the upper left corner, width, and height of the part of the original image
	// that we'll be displaying.  This is useful if you have several frames in one image file
	// -- you can advance clip* to go between frames, and thus animate the sprite
	int clipX_, clipY_, clipWidth_, clipHeight_;

	bool flipHorizontal_, flipVertical_;
	double angleOfRotation_;

	//SDL_Rect boundingRectangle_; //what's its offset; and how much of the original image will we use?
};

//5-19-2016
//inline void SSDL_SetSpriteImage(SSDL_Sprite& s, SDL_Texture* img) { s.setImage(img); }
inline void SSDL_SetSpriteImage(SSDL_Sprite& s, const SSDL_Image& img) { s.setImage(img); }
inline void SSDL_SetSpriteLocation(SSDL_Sprite& sprite, int x, int y) { sprite.x() = x; sprite.y() = y; }
inline void SSDL_SetSpriteSize(SSDL_Sprite& sprite, int w, int h) { sprite.width() = w; sprite.height() = h; }
inline void SSDL_SetSpriteOffset(SSDL_Sprite& sprite, int x, int y) { sprite.offsetX() = x; sprite.offsetY() = y; }
inline void SSDL_SetSpriteClipLocation(SSDL_Sprite& sprite, int w, int h) { sprite.clipX() = w; sprite.clipY() = h; }
inline void SSDL_SetSpriteClipSize(SSDL_Sprite& sprite, int w, int h) { sprite.clipWidth() = w; sprite.clipHeight() = h; }
inline void SSDL_SetSpriteRotation(SSDL_Sprite& sprite, double angle) { sprite.angleOfRotation() = angle; }
inline void SSDL_SpriteFlipHorizontal(SSDL_Sprite& sprite) { sprite.flipHorizontal() = !sprite.flipHorizontal(); }
inline void SSDL_SpriteFlipVertical(SSDL_Sprite& sprite) { sprite.flipVertical() = !sprite.flipVertical(); }

inline int  SSDL_GetSpriteX(const SSDL_Sprite& s) { return s.x(); }
inline int  SSDL_GetSpriteY(const SSDL_Sprite& s) { return s.y(); }
inline int  SSDL_GetSpriteWidth(const SSDL_Sprite& s) { return s.width(); }
inline int  SSDL_GetSpriteHeight(const SSDL_Sprite& s) { return s.height(); }
inline int  SSDL_GetSpriteOffsetX(const SSDL_Sprite& s) { return s.offsetX(); }
inline int  SSDL_GetSpriteOffsetY(const SSDL_Sprite& s) { return s.offsetY(); }
inline int  SSDL_GetSpriteClipX(const SSDL_Sprite& s) { return s.clipX(); }
inline int  SSDL_GetSpriteClipY(const SSDL_Sprite& s) { return s.clipY(); }
inline int  SSDL_GetSpriteClipWidth(const SSDL_Sprite& s) { return s.clipWidth(); }
inline int	SSDL_GetSpriteClipHeight(const SSDL_Sprite& s) { return s.clipHeight(); }
inline bool SSDL_GetSpriteFlipHorizontal(const SSDL_Sprite& s) { return s.flipHorizontal(); }
inline bool SSDL_GetSpriteFlipVertical(const SSDL_Sprite& s) { return s.flipVertical(); }
inline double SSDL_GetSpriteRotation(const SSDL_Sprite& s) { return s.angleOfRotation(); }


inline void SSDL_RenderSprite(const SSDL_Sprite& sprite) //too long for inline -- and costs even if you never use offset! WSB
{
	SDL_Rect destination = sprite.destination();
	SSDL_RenderImageEx(sprite, sprite.source(), destination, sprite.angleOfRotation(),
		(SDL_RendererFlip)((int(sprite.flipHorizontal()) * SDL_FLIP_HORIZONTAL) | (int(sprite.flipVertical()) * SDL_FLIP_VERTICAL)));
}

inline bool SSDL_SpriteHasIntersection(const SSDL_Sprite& aIn, const SSDL_Sprite& bIn)
{
	//WSB: can this be made more efficient by passing in an SDL_Rect to SSDL_Sprite::destination? WSB 7-26-2016
	SDL_Rect aDest = aIn.destination(), bDest = bIn.destination();
	return (SDL_HasIntersection(&aDest, &bDest) != SDL_FALSE);

	//	return (SDL_HasIntersection (&aIn.destination(), &bIn.destination()) != SDL_FALSE);
}

const SSDL_Sprite& SSDL_Sprite::operator= (const SSDL_Sprite& other)
{
	x_ = other.x_;				y_ = other.y_;
	width_ = other.width_;		height_ = other.height_;
	clipX_ = other.clipX_;		clipY_ = other.clipY_;
	clipWidth_ = other.clipWidth_; clipHeight_ = other.clipHeight_;
	offsetX_ = other.offsetX_;	offsetY_ = other.offsetY_;

	angleOfRotation_ = other.angleOfRotation_;
	flipVertical_ = other.flipVertical_;
	flipHorizontal_ = other.flipHorizontal_;

	SSDL_Image::operator= (other);

	return *this;
}

void SSDL_Sprite::zeroFields()
{
	x_ = y_ = 0;
	clipX_ = clipY_ = 0;
	offsetX_ = offsetY_ = 0;

	clipWidth_ = clipHeight_ = 0;

	width_ = clipWidth_;
	height_ = clipHeight_;

	angleOfRotation_ = 0.0;
	flipHorizontal_ = flipVertical_ = false;
}

void SSDL_Sprite::setImage(const SSDL_Image& t)
{
	SSDL_Image::operator= (t);

	zeroFields();

	if (t)
		SSDL_QueryImage(t, clipWidth_, clipHeight_);

	width_ = clipWidth_;
	height_ = clipHeight_;
}

SDL_Rect SSDL_Sprite::destination()	const	//rectangle that's where it'll go on the screen
{
	SDL_Rect result = { x_, y_, width_, height_ };
	result.x -= offsetX();		//apply offset
	result.y -= offsetY();
	return result;
}

SDL_Rect SSDL_Sprite::source() const		//rectangle that's where it's coming from in the image
{
	SDL_Rect result = { clipX_, clipY_, clipWidth_, clipHeight_ };
	return result;
}

//draw

inline
void SSDL_RenderDrawPoint(int x, int y)
{
	if (SDL_RenderDrawPoint(SSDL_Display::Instance(), x, y) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderDrawPoints(const SDL_Point* points, int count)
{
	if (SDL_RenderDrawPoints(SSDL_Display::Instance(), points, count) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderDrawLine(int x1, int y1, int x2, int y2)
{
	if (SDL_RenderDrawLine(SSDL_Display::Instance(), x1, y1, x2, y2) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderDrawLines(const SDL_Point* points, int count)
{
	if (SDL_RenderDrawLines(SSDL_Display::Instance(), points, count) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderDrawRect(int x, int y, int w, int h)
{
	SDL_Rect rect = { x, y, w, h };
	if (SDL_RenderDrawRect(SSDL_Display::Instance(), &rect) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderDrawRect(const SDL_Rect& rect)
{
	if (SDL_RenderDrawRect(SSDL_Display::Instance(), &rect) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderDrawRects(const SDL_Rect* rects, int count)
{
	if (SDL_RenderDrawRects(SSDL_Display::Instance(), rects, count) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderFillRect(int x, int y, int w, int h)
{
	SDL_Rect rect = { x, y, w, h };
	if (SDL_RenderFillRect(SSDL_Display::Instance(), &rect) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderFillRect(const SDL_Rect& rect)
{
	if (SDL_RenderFillRect(SSDL_Display::Instance(), &rect) < 0) throw SSDL_Exception();
}

inline
void SSDL_RenderFillRects(const SDL_Rect* rects, int count)
{
	if (SDL_RenderFillRects(SSDL_Display::Instance(), rects, count) < 0) throw SSDL_Exception();
}

struct SSDL_Circle
{
	int x, y, radius;
};

void SSDL_RenderDrawCircle(int x, int y, int radius);
void SSDL_RenderFillCircle(int x, int y, int radius);
void SSDL_RenderDrawCircles(SSDL_Circle* circles, int count);
void SSDL_RenderFillCircles(SSDL_Circle* circles, int count);

#define PI 3.14159

//http://content.gpwiki.org/index.php/SDL:Tutorials:Drawing_and_Filling_Circles has another method
//it may look better but it's incomprehensible

void SSDL_RenderFillCircle(int xc, int yc, int radius)
{
	for (int dy = -radius; dy <= radius; ++dy)
	{
		//x^2 + y^2 = r^2, so x = sqrt (r^2 - y^2)
		int dx = int(sqrt(radius*radius - dy * dy) + 0.5);
		SSDL_RenderDrawLine(xc - dx, yc + dy, xc + dx, yc + dy);
	}
}

void SSDL_RenderDrawCircle(int xc, int yc, int radius)
{
	//What angleIncrement should we use?  one that subtends about a pixel
	//sin(angleIncrement) = 1 / radius
	double angleIncrement = asin(1.0 / radius);

	for (double angle = 0; angle <= 2 * PI; angle += angleIncrement)
	{
		int y = int(radius * sin(angle) + 0.5);
		int x = int(radius * cos(angle) + 0.5);
		SSDL_RenderDrawPoint(xc + x, yc + y);
	}
}

void SSDL_RenderDrawCircles(SSDL_Circle* circles, int count)
{
	for (int i = 0; i < count; ++i)
		SSDL_RenderDrawCircle(circles[i].x, circles[i].y, circles[i].radius);
}

void SSDL_RenderFillCircles(SSDL_Circle* circles, int count)
{
	for (int i = 0; i < count; ++i)
		SSDL_RenderFillCircle(circles[i].x, circles[i].y, circles[i].radius);
}


////  end SSDL stuff



